
/*
 * Generated by TPTC - Translate Pascal to C
 *     Version 1.7 03/26/88   (C) 1988 S.H.Smith
 */
#include "tptcmac.h"

/*
 * Example of multi-dimensional array manipulation
 */ 

 /* program puzzle  */ 


  #define xsize 511    /*  d*d*d-1 */ 
  #define classmax 3  
  #define typemax 12  
  #define d    8  


  typedef int  /* 0..3 */ piececlass; 
  typedef int  /* 0..12 */ piecetype; 
  typedef int  /* 0..511 */ position; 


  int          /* 0..13 */ piececount[ /* piececlass */ 4]; 
  piececlass   class[ /* piecetype */ 13]; 
  position     piecemax[ /* piecetype */ 13]; 
  boolean      puzzle[ /* position */ 512]; 
  boolean      p[ /* piecetype */ 13][ /* position */ 512]; 
  boolean      p2[ /* piecetype */ 13][ /* position */ 512];   /* alternate form */ 
  position     m, n; 
  int          /* 0..13 */ i, j, k; 
  integer      kount; 

  
boolean      fit(piecetype    i,
                 position     j)
  { 
  
    position     k; 
  
    return false; 
    for (k = 0; k <= piecemax[i]; k++) 
      if (p[i][k]) 
        if (puzzle[j + k]) 
          goto label_1;
    return true; 

label_1: 
  } 

  

position     place(piecetype    i,
                   position     j)
  { 
    
  
    position     k; 
  
    for (k = 0; k <= piecemax[i]; k++) 
      if (p[i][k]) 
        puzzle[j + k] = true; 
    piececount[class[i]] = piececount[class[i]] - 1; 
    for (k = j; k <= xsize; k++) 
      if (!puzzle[k]) 
        { 
          return k; 
          goto label_1;
        } 
    printf("Puzzle filled\n"); 
    return 0; 

label_1: 
  } 

  

void         remove(piecetype    i,
                    position     j)
  { 
    position     k; 
  
    for (k = 0; k <= piecemax[i]; k++) 
      if (p[i][k]) 
        puzzle[j + k] = false; 
    piececount[class[i]] = piececount[class[i]] + 1; 
  } 

  

boolean      trial(position     j)
  { 
    piecetype    i; 
    position     k; 
  
    for (i = 0; i <= typemax; i++) 
      if (piececount[class[i]] != 0) 
        if (fit(i,j)) 
          { 
            k = place(i,j); 
            if (trial(k) || (k == 0)) 
              { 
                  /* writeln( 'Piece', i + 1, ' at', k + 1); */ 
                return true; 
                return;
              } 
            else 
              remove(i,j); 
          } 
    return false; 
    kount = kount + 1; 
  } 


main(int   argc,
     char  *argv[])
{ 
  printf("Solving puzzle...\n"); 
  for (m = 0; m <= xsize; m++) 
    puzzle[m] = true; 
  for (i = 1; i <= 5; i++) 
    for (j = 1; j <= 5; j++) 
      for (k = 1; k <= 5; k++) 
        puzzle[i + d * (j + d * k)] = false; 

  for (i = 0; i <= typemax; i++) 
    for (m = 0; m <= xsize; m++) 
      p[i][m] = false; 

  for (i = 0; i <= 3; i++) 
    for (j = 0; j <= 1; j++) 
      for (k = 0; k <= 0; k++) 
        p[0][i + d * (j + d * k)] = true; 

  class[0] = 0; 
  piecemax[0] = 3 + d * 1 + d * d * 0; 
  for (i = 0; i <= 1; i++) 
    for (j = 0; j <= 0; j++) 
      for (k = 0; k <= 3; k++) 
        p[1][i + d * (j + d * k)] = true; 

  class[1] = 0; 
  piecemax[1] = 1 + d * 0 + d * d * 3; 
  for (i = 0; i <= 0; i++) 
    for (j = 0; j <= 3; j++) 
      for (k = 0; k <= 1; k++) 
        p[2][i + d * (j + d * k)] = true; 

  class[2] = 0; 
  piecemax[2] = 0 + d * 3 + d * d * 1; 
  for (i = 0; i <= 1; i++) 
    for (j = 0; j <= 3; j++) 
      for (k = 0; k <= 0; k++) 
        p[3][i + d * (j + d * k)] = true; 

  class[3] = 0; 
  piecemax[3] = 1 + d * 3 + d * d * 0; 
  for (i = 0; i <= 3; i++) 
    for (j = 0; j <= 0; j++) 
      for (k = 0; k <= 1; k++) 
        p[4][i + d * (j + d * k)] = true; 

  class[4] = 0; 
  piecemax[4] = 3 + d * 0 + d * d * 1; 
  for (i = 0; i <= 0; i++) 
    for (j = 0; j <= 1; j++) 
      for (k = 0; k <= 3; k++) 
        p[5][i + d * (j + d * k)] = true; 

  class[5] = 0; 
  piecemax[5] = 0 + d * 1 + d * d * 3; 
  for (i = 0; i <= 2; i++) 
    for (j = 0; j <= 0; j++) 
      for (k = 0; k <= 0; k++) 
        p[6][i + d * (j + d * k)] = true; 

  class[6] = 1; 
  piecemax[6] = 2 + d * 0 + d * d * 0; 
  for (i = 0; i <= 0; i++) 
    for (j = 0; j <= 2; j++) 
      for (k = 0; k <= 0; k++) 
        p[7][i + d * (j + d * k)] = true; 

  class[7] = 1; 
  piecemax[7] = 0 + d * 2 + d * d * 0; 
  for (i = 0; i <= 0; i++) 
    for (j = 0; j <= 0; j++) 
      for (k = 0; k <= 2; k++) 
        p[8][i + d * (j + d * k)] = true; 

  class[8] = 1; 
  piecemax[8] = 0 + d * 0 + d * d * 2; 
  for (i = 0; i <= 1; i++) 
    for (j = 0; j <= 1; j++) 
      for (k = 0; k <= 0; k++) 
        p[9][i + d * (j + d * k)] = true; 

  class[9] = 2; 
  piecemax[9] = 1 + d * 1 + d * d * 0; 
  for (i = 0; i <= 1; i++) 
    for (j = 0; j <= 0; j++) 
      for (k = 0; k <= 1; k++) 
        p[10][i + d * (j + d * k)] = true; 

  class[10] = 2; 
  piecemax[10] = 1 + d * 0 + d * d * 1; 
  for (i = 0; i <= 0; i++) 
    for (j = 0; j <= 1; j++) 
      for (k = 0; k <= 1; k++) 
        p[11][i + d * (j + d * k)] = true; 

  class[11] = 2; 
  piecemax[11] = 0 + d * 1 + d * d * 1; 
  for (i = 0; i <= 1; i++) 
    for (j = 0; j <= 1; j++) 
      for (k = 0; k <= 1; k++) 
        p[12][i + d * (j + d * k)] = true; 

  class[12] = 3; 
  piecemax[12] = 1 + d * 1 + d * d * 1; 
  piececount[0] = 13; 
  piececount[1] = 3; 
  piececount[2] = 1; 
  piececount[3] = 1; 
  m = 1 + d * (1 + d * 1); 
  kount = 0; 

  if (fit(0,m)) 
    n = place(0,m); 
  else 
    printf(" error 1\n"); 

  if (trial(n)) 
    printf(" success in %d trials\n",kount); 
  else 
    printf(" failure\n"); 
}



