
/*
 * Generated by TPTC - Translate Pascal to C
 *     Version 1.7 03/26/88   (C) 1988 S.H.Smith
 */
#include "tptcmac.h"

/*
 * This program demonstrates some weaknesses in TPC 1.4 and TPC 1.5.  Unless
 * otherwise noted, all failed translations are in 1.4 and corrected in 1.5.
 *
 */ 

 /* program test  */ 


   integer      *vector = MK_FP(0x0000,0x03c4); 
                        /* absolute variables not translated in tpc 1.5 */ 

   char         ch; 
   boolean      ibmat; 
   boolean      control; 


  typedef char longstring[256]; 

  typedef integer lookup[7][2]; 
                        /* multi-dimension array declarations not translated
                           in tpc 1.5 */ 

  typedef integer nestedarray[7][2]; 
                        /* nested arrays not translated in tpc 1.5 */ 

  typedef char mytype1; 
  typedef byte mytype2; 
  typedef integer mytype3; 
  typedef char mytype4[81]; 

  typedef struct myrec { 
     longstring   astr; 
     real         areal; 
     integer      aint; 
     char         achar; 
  } myrec; 


  lookup       tab   /*  this goes haywire here       */ 
                      = {{10, 824}, {9, 842}, {9, 858}, {9, 874}, 
                      {10, 890}, {9, 908}, {9, 924}}; 


void         invvid(char *       m)  /* added */ 
{ 
   printf("%s\n",m); 
} 


void         call_a(void)
{ 
   char         s1[STRSIZ], s2[STRSIZ]; 

   strcpy(s1,"filename"); 
   sbld(s2,"#include \"%s\"  ",s1); 
} 


void         call_b(integer      l,
                    lookup       table)
{ 
   #define seg_addr 0x0040    /* constants added */ 
   #define filter_ptr 0x200  
   #define vert '|'  
   #define dbl  "=="  


  printf("%d",peek(seg_addr,filter_ptr) + 1); gotoxy(4,4); 
  gotoxy(4,11); 

  /*  put this next line in blows up in 1.4 --  */ 
          invvid(scat("%c Retrieve %s Save %s Combine %s Xtract %s Erase %s List %s Import %s Directory %c",vert,dbl,dbl,dbl,dbl,dbl,dbl,dbl,vert)); 
} 

  /* untyped */ 
                       
void         usesuntyped(integer      width,
                         void *       base,
                         integer      size)
{ 
   byte         *buf[1000] = base; 
                     /* absolutes not translated in 1.6 */ 
   integer      i; 

   for (i = 1; i <= size; i++) 
      printf("%d: %*d\n",i,width,buf[i-1]); 
} 



void         myprocmess(void *       v1,
                        void *       v2,
                        void *       v3)
           /* untyped params not translated in tpc1.5 */ 
{ 
    mytype1      *xv1 = v1; 
    mytype2      *xv2 = v2; 
    mytype3      *xv3 = v3; 
    mytype4      *xv4 = v3; /* this is the dirtiest of the lot */ 
                    /* absolute variables not translated in tpc1.5 */ 
    integer      othvar1; 
    char         othvar2; 


    othvar1 = *xv1; 
    othvar2 = *xv2; 
    othvar1 = *xv3; 
    othvar2 = first(*xv4); 
                    /* implicit conversion of absolute variables to
                   pointer deref's produced by tptc1.6 */ 
} 


void         varparams(integer *    i,
                       real *       r,
                       char *       s)
{ 
   *i = 100; 
   *r = 100.1; 
   strcpy(s,"some string"); 
   s[4] = '!'; 
} 



void         test_untyped(void)
{ 
   real         r; 
   integer      i; 
   char         s[STRSIZ]; 

   r = 1.2; 
   i = 99; 
   strcpy(s,"some string"); 
   myprocmess(&r,&i,s); 

   usesuntyped(10,s,2); 
   usesuntyped(8,&r,3); 
   usesuntyped(2,&i,3); 

   varparams(&i,&r,s); 

   sbld(s,"%3.1f",r);   /* should generate sbld call */ 
   val(s,&r,&i);   /* should pass address of r and i */ 
} 


void         testrec(void)
{ 
   myrec        rec1; 
   myrec        rec2; 

   #define limit 1000  

   strcpy(rec1.astr,"some string"); 
   rec1.astr[4] = '-'; 
   rec1.areal = 1.23; 
   rec1.achar = 'x'; 
   rec1.aint = limit; 
   printf("str=%s r=%f i=%d c=%c\n",rec1.astr,rec1.areal,rec1.aint,rec1.achar); 
   rec2 = rec1; 
} 


/* TPTC: TEST.PAS(167): Warning: Nested function, tok=inner */
      
void         AL_inner(void)
           /* name will clash with outer version of inner */ 
      { 
         outervar = 1; 
           /* inmost */ 
      } 

   

/* TPTC: TEST.PAS(164): Warning: Nested function, tok=inner */
   
void         inner(void)
        /* outer version of inner */ 

      { 
   /* Nested function: AL_inner */ 

      integer      innervar; 
   
      AL_inner();   /* outer version of inner */ 
      innervar = outerpar; 
      outervar = innervar + limit; 
   } 


void         test_nesting(integer      outerpar)
{ 
   #define limit 2000    /* clashes with testrec's limit? */ 

   integer      outervar; 

   
   /* Nested function: inner */ 

   AL_inner(); 
   outervar = outerpar; 
   printf("\r\nThis wouldn't translate in tpc1.5!"); 
   printf("\r\nThis wouldn't translate in tpc1.5!\r\n"); 
   printf("This wouldn't translate in tpc1.5!\r\n"); 
} 


void         main_block(void)
{ 
   if (peekb(0xffff,0x0e) == 0xFC) 
   { 
     ibmat = true; 
   } 

 do { 
   if (ibmat) 
     { 
       control = true; 
     } 
   else 

   switch (ch) {
      
      case '1':   
      case '2':   
      case '3':   
      case '4':   
      case '5':   
      case '6':   
      case '7':   
      case '8':   call_a();   /*  1.4 fails to put in cases from 2 to 7  */ 
      break; 
      
      case 'Z':   call_a(); 
      break; 
      
      case 'z':   { 
      }   /*  do nothing   */ 
       break; 
       
       default: 
             /*  Do Nothing  */ 
      } 

   }  while (!((ch == '\r') || (ch == 'Z'))); 
} 




main(int   argc,
     char  *argv[])
{ 
   /* main block */ 
   main_block(); 
}



