
/*
 * Generated by TPTC - Translate Pascal to C
 *     Version 1.7 03/26/88   (C) 1988 S.H.Smith
 */
#include "tptcmac.h"

/*
 DEARC.PAS - Program to extract all files from an archive created by version
             5.12 or earlier of the ARC utility.

   *** ORIGINAL AUTHOR UNKNOWN ***
*/ 

 /* program dearcsq  */ 

/* R(OFF) */   
/* U(OFF) */   
/* C(OFF) */   
/* K(OFF) */   


      #define blocksize 128  
      #define arcmarc 26    /*  special archive marker  */ 
      #define arcver 9    /*  max archive header version code  */ 
      #define strlen 100    /*  standard string length  */ 
      #define fnlen 12    /*  file name length - 1  */ 


  integer      crctab[256] 
   = {0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 
    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 
    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 
    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 
    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 
    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 
    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 
    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 
    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 
    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 
    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 
    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 
    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 
    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 
    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 
    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 
    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 
    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 
    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 
    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 
    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 
    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 
    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 
    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 
    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 
    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 
    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 
    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 
    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 
    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 
    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 
    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040}; 


     typedef struct longtype {   /*  used to simulate long (4 byte) integers  */ 
                 
               integer      l, h; } longtype; 

     typedef char strtype[strlen+1]; 
     typedef char fntype[fnlen+1]; 
     typedef byte buftype[blocksize]; 
     typedef struct heads { 
                 fntype       name; 
                 longtype     size; 
                 integer      date; 
                 integer      time; 
                 integer      crc; 
                 
               longtype     
/* TPTC: UNSQ.PAS(73): Warning: Redeclaration not identical, tok=length */
               length; } heads; 


    byte         hdrver; 
    int          /* untyped file */ arcfile; 
    buftype      arcbuf; 
    integer      arcptr; 
    strtype      arcname; 
    boolean      endfile; 
    int          /* untyped file */ extfile; 
    buftype      extbuf; 
    integer      extptr; 
    strtype      extname; 

  /*  definitions for unpack  */ 


   #define dle  0x90  


   enum {  nohist,inrep } state; 
   integer      crcval; 
   real         
/* TPTC: UNSQ.PAS(95): Warning: Redeclaration not identical, tok=size */
   size; 
   integer      lastc; 

  /*  definitions for unsqueeze  */ 


   #define error -1  
   #define speof 256  
   #define numvals 256    /*  1 less than the number of values  */ 


   typedef struct nd { 
           
        integer      child[2]; } nd; 


   nd           node[numvals+1]; 
   integer      bpos; 
   integer      curin; 
   integer      numnodes; 

  /*  definitions for uncrunch  */ 


   #define tabsize 4096  
   #define tabsizem1 4095  
   #define no_pred 0xFFFF  
   #define empty 0xFFFF  


   typedef struct entry { 
              boolean      used; 
              integer      next; 
              integer      predecessor; 
              
           byte         follower; } entry; 


   byte         stack[tabsizem1+1]; 
   integer      sp; 
   entry        string_tab[tabsizem1+1]; 


   integer      code_count; 
   integer      code; 
   boolean      firstc; 
   integer      oldcode; 
   integer      finchar; 
   integer      inbuf; 
   integer      outbuf; 
   boolean      newhash; 

  /*  definitions for dynamic uncrunch  */ 


  #define crunch_bits 12  
  #define squash_bits 13  
  #define hsize 8192  
  #define init_bits 9  
  #define first 257  
  #define clear 256  
  #define hsizem1 8191  
  #define bitsm1 12  

  byte         rmask[9] 
   = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff}; 


  integer      bits, n_bits, maxcode; 
  integer      prefix[hsizem1+1]; 
  byte         suffix[hsizem1+1]; 
  byte         buf[bitsm1+1]; 
  integer      clear_flg; 
  byte         stack1[hsizem1+1]; 
  integer      free_ent; 
  integer      maxcodemax; 
  integer      offset, sizex; 
  boolean      firstch; 


void         abortme(char *       s)
  /*  terminate the program with an error message  */ 
{ 
  printf("ABORT: %s\n",s); 
  exit(0);
} /* proc abortme */ 


char *       fn_to_str(fntype *     fn)
  /*  convert strings from C format (trailing 0) to Turbo Pascal format (leading
    length byte).  */ 
{ strtype      s; 
    integer      i; 

  strcpy(s,""); 
  i = 0; 
  while (fn[i] != '\x00') { 
    sbld(s,"%s%c",s,fn[i]); 
    i = i + 1; 
    } 
  return s; } /* func fn_to_str */ 


real         unsigned_to_real(integer      u)
  /*  convert unsigned integer to real  */ 
  /*  note: INT is a function that returns a REAL!!! */ 
{ 
  if (u >= 0) 
    return int(u); 
  else 
  if (u == 0x8000) 
    return 32768.0; 
  else 
    return 65536.0 + u; } /* func unsigned_to_real */ 


real         long_to_real(longtype     l)
  /*  convert longtype integer to a real  */ 
  /*  note: INT is a function that returns a REAL!!!  */ 
{ real         r; 
    enum {  posit,neg } s; 
#define rcon 65536.0  

  if (l.h >= 0) { 
    r = int(l.h) * rcon; 
      /* notice: no ";" here */ 
    s = posit; 
    } 
  else { 
    s = neg; 
    if (l.h == 0x8000) 
      r = rcon * rcon; 
    else 
      r = int(-l.h) * rcon; 
    } 
  r = r + unsigned_to_real(l.l); 
  if (s == neg) 
    return -r; 
  else 
    return r; } /* func long_to_real */ 


void         read_block(void)
  /*  read a block from the archive file  */ 
{ 
  if (feof(arcfile)) 
    endfile = true; 
  else 
    blockread(arcfile,arcbuf,1); 
  arcptr = 1; } /* proc read_block */ 


void         write_block(void)
  /*  write a block to the extracted file  */ 
{ 
  blockwrite(extfile,extbuf,1); 
  extptr = 1; } /* proc write_block */ 


void         open_arc(void)
  /*  open the archive file for input processing  */ 
{ 
  /* I(OFF) */   assign(arcfile,arcname); /* I(ON) */   
  if (ioresult != 0) 
    abortme("Cannot open archive file."); 
  /* I(OFF) */   reset(&arcfile); /* I(ON) */   
  if (ioresult != 0) 
    abortme("Cannot open archive file."); 
  endfile = false; 
  read_block(); } /* proc open_arc */ 


void         open_ext(void)
  /*  open the extracted file for writing  */ 
{ 
  /* I(OFF) */   assign(extfile,extname); /* I(ON) */   
  if (ioresult != 0) 
    abortme("Cannot open extract file."); 
  /* I(OFF) */   rewrite(&extfile); /* I(ON) */   
  if (ioresult != 0) 
    abortme("Cannot open extract file."); 
  extptr = 1; 
} /* proc open_ext */ 


byte         get_arc(void)
  /*  read 1 character from the archive file  */ 
{ 
  if (endfile) 
    return 0; 
  else { 
    return arcbuf[arcptr]; 
    if (arcptr == blocksize) 
      read_block(); 
    else 
      arcptr = arcptr + 1; 
    } 
} /* func get_arc */ 


void         put_ext(byte         c)
  /*  write 1 character to the extracted file  */ 
{ 
  extbuf[extptr] = c; 
  if (extptr == blocksize) 
    write_block(); 
  else 
    extptr = extptr + 1; } /* proc put_ext */ 


void         close_arc(void)
  /*  close the archive file  */ 
{ 
  fclose(arcfile); } /* proc close_arc */ 


void         close_ext(void)
  /*  close the extracted file  */ 
{ 
  while (extptr != 1) 
    put_ext(ord('\x1A'));   /*  pad last block w/ Ctrl-Z (EOF)  */ 
  fclose(extfile); } /* proc close_ext */ 


void         fseek(real         offset,
                   integer      base)
  /*  re-position the current pointer in the archive file  */ 
{ real         b; 
    integer      i, ofs, rec; 
    byte         c; 

  switch (base) {
    
    case 0:   b = offset; 
    break; 
    
    case 1:   b = offset + (unsigned_to_real(filepos(arcfile)) - 1.0) * blocksize + arcptr - 1.0; 
    break; 
    
    case 2:   b = offset + unsigned_to_real(filesize(arcfile)) * blocksize - 1.0; break; 
    
    default: 
      abortme("Invalid parameters to fseek"); } 
  rec = trunc(b / blocksize); 
  ofs = trunc(b - (int(rec) * blocksize));   /*  Int converts to Real  */ 
  seek(arcfile,rec); 
  read_block(); 
  for (i = 1; i <= ofs; i++) 
    c = get_arc(); } /* proc fseek */ 


void         fread(void *       buf,
                   integer      reclen)
  /*  read a record from the archive file  */ 
{ integer      i; 
    byte         *b[maxint] = buf; 

  for (i = 1; i <= reclen; i++) 
    b[i-1] = get_arc(); } /* proc fread */ 


void         getarcname(void)
  /*  get the name of the archive file  */ 
{ integer      i; 

  if (paramcount > 1) 
    abortme("Too many parameters"); 
  if (paramcount == 1) 
    strcpy(arcname,paramstr(1)); 
  else { 
    printf("Enter archive filename: "); 
    fscanv(stdin,"#\n",arcname); 
    if (strcmp(arcname,"") == 0) 
      abortme("No file name entered"); 
    printf("\n"); 
    printf("\n"); 
    } 
  for (i = 1; i <= length(arcname); i++) 
    arcname[i-1] = toupper(arcname[i-1]); 
  if (cpos('.',arcname) == 0) 
    sbld(arcname,"%s.ARC",arcname); } /* proc GetArcName */ 


boolean      readhdr(heads *      hdr)
  /*  read a file header from the archive file  */ 
  /*  FALSE = eof found; TRUE = header found  */ 
{ fntype       name; 
    integer      try; 

  try = 10; 
  if (endfile) { 
    return false; 
    return;
    } 
  while (get_arc() != arcmarc) { 
    if (try == 0) 
      abortme(scat("%s is not an archive",arcname)); 
    try = try - 1; 
    printf("%s is not an archive, or is out of sync\n",arcname); 
    if (endfile) 
      abortme("Archive length error"); 
    } /* while */ 
  hdrver = get_arc(); 
  if (hdrver < 0) 
    abortme(scat("Invalid header in archive %s",arcname)); 
  if (hdrver == 0) {   /*  special end of file marker  */ 
    return false; 
    return;
    } 
  if (hdrver > arcver) { 
    fread(name,fnlen); 
    printf("I dont know how to handle file %s in archive %s\n",fn_to_str(name),arcname); 
    printf("I think you need a newer version of DEARC.\n"); 
    exit(0);
    } 
  if (hdrver == 1) { 
    fread(hdr,sizeof(heads) - sizeof(longtype)); 
    hdrver = 2; 
    hdr->length = hdr->size; 
    } 
  else 
    fread(hdr,sizeof(heads)); 
  return true; 
} /* func readhdr */ 


void         putc_unp(integer      c)
{ 
  crcval = ((crcval >> 8) & 0x00FF) ^ crctab[(crcval ^ c) & 0x00FF]; 
  put_ext(c); } /* proc putc_unp */ 


void         putc_ncr(integer      c)
{ 
  switch (state) {
    
    case nohist:   if (c == dle) 
               state = inrep; 
    else { 
               lastc = c; 
               putc_unp(c); 
               } 
    break; 
    
    case inrep:   { 
             if (c == 0) 
               putc_unp(dle); 
             else { 
               c = c - 1; 
               while ((c != 0)) { 
                 putc_unp(lastc); 
                 c = c - 1; 
                 } 
               } 
             state = nohist; 
             } 
    break; 
    } /* case */ 
} /* proc putc_ncr */ 


integer      getc_unp(void)
{ 
  if (size == 0.0) 
    return -1; 
  else { 
    size = size - 1.0; 
    return get_arc(); 
    } 
} /* func getc_unp */ 


void         init_usq(void)
  /*  initialize for unsqueeze  */ 
{ integer      i; 

  bpos = 99; 
  fread(&numnodes,sizeof(numnodes)); 
  if ((numnodes < 0) || (numnodes > numvals)) 
    abortme("File has an invalid decode tree"); 
  node[0].child[0] = -(speof + 1); 
  node[0].child[1] = -(speof + 1); 
  for (i = 0; i <= numnodes - 1; i++) { 
    fread(&node[i].child[0],sizeof(integer)); 
    fread(&node[i].child[1],sizeof(integer)); 
    } 
} /* proc init_usq; */ 


integer      getc_usq(void)
  /*  unsqueeze  */ 
{ integer      i; 

  i = 0; 
  while (i >= 0) { 
    bpos = bpos + 1; 
    if (bpos > 7) { 
      curin = getc_unp(); 
      if (curin == error) { 
        return error; 
        return;
        } 
      bpos = 0; 
      i = node[i].child[1 & curin]; 
      } 
    else { 
      curin = curin >> 1; 
      i = node[i].child[1 & curin]; 
      } 
    } /* while */ 
  i = -(i + 1); 
  if (i == speof) 
    return -1; 
  else 
    return i; 
} /* func getc_usq */ 


integer      h(integer      pred,
               integer      foll)
/* TPTC: UNSQ.PAS(497): Warning: Redeclaration not identical, tok=h */

  /*  calculate hash value  */ 
  /*  thanks to Bela Lubkin  */ 
{ real         local; 
    char         s[21]; 
    integer      i, v; 
    char         c; 

if (!newhash) 
{ 
  local = (pred + foll) | 0x0800; 
  if (local < 0.0) 
    local = local + 65536.0; 
  local = (local * local) / 64.0; 
  /*  convert Local to an integer, truncating high order bits.  */ 
  /*  there ***MUST*** be a better way to do this!!!  */ 
  sbld(s,"%15.5f",local); 
  v = 0; 
  i = 1; 
  c = s[0]; 
  while (c != '.') { 
    if ((c >= '0') && (c <= '9')) 
      v = v * 10 + (ord(c) - ord('0')); 
    i = i + 1; 
    c = s[i-1]; 
    } 
  return v & 0x0FFF; 
} /* func h */ 
else 
{ 
  local = (pred + foll) * 15073; 
  /*  convert Local to an integer, truncating high order bits.  */ 
  /*  there ***MUST*** be a better way to do this!!!  */ 
  sbld(s,"%15.5f",local); 
  v = 0; 
  i = 1; 
  c = s[0]; 
  while (c != '.') { 
    if ((c >= '0') && (c <= '9')) 
      v = v * 10 + (ord(c) - ord('0')); 
    i = i + 1; 
    c = s[i-1]; 
    } 
  return v & 0x0FFF; 
} 
} 


integer      eolist(integer      index)
{ integer      temp; 

  temp = string_tab[index].next; 
  while (temp != 0) { 
    index = temp; 
    temp = string_tab[index].next; 
    } 
  return index; } /* func eolist */ 


integer      hash(integer      pred,
                  integer      foll)
{ integer      local; 
    integer      tempnext; 

  local = h(pred,foll); 
  if (!string_tab[local].used) 
    return local; 
  else { 
    local = eolist(local); 
    tempnext = (local + 101) & 0x0FFF; 
    while (string_tab[tempnext].used) { 
      tempnext = tempnext + 1; 
      if (tempnext == tabsize) 
        tempnext = 0; 
      } 
    string_tab[local].next = tempnext; 
    return tempnext; 
    } 
} /* func hash */ 


void         upd_tab(integer      pred,
                     integer      foll)
{ 
  { void *with1 = &string_tab[hash(pred,foll)]; 
    with1->used = true; 
    with1->next = 0; 
    with1->predecessor = pred; 
    with1->follower = foll; 
   } 
} /* proc upd_tab */ 


integer      gocode(void)
{ integer      localbuf; 
    integer      returnval; 

  if (inbuf == empty) { 
    localbuf = getc_unp(); 
    if (localbuf == -1) { 
      return -1; 
      return;
      } 
    localbuf = localbuf & 0x00FF; 
    inbuf = getc_unp(); 
    if (inbuf == -1) { 
      return -1; 
      return;
      } 
    inbuf = inbuf & 0x00FF; 
    returnval = ((localbuf << 4) & 0x0FF0) + ((inbuf >> 4) & 0x000F); 
    inbuf = inbuf & 0x000F; 
    } 
  else { 
    localbuf = getc_unp(); 
    if (localbuf == -1) { 
      return -1; 
      return;
      } 
    localbuf = localbuf & 0x00FF; 
    returnval = localbuf + ((inbuf << 8) & 0x0F00); 
    inbuf = empty; 
    } 
  return returnval; 
} /* func gocode */ 


void         push(integer      c)
{ 
  stack[sp] = c; 
  sp = sp + 1; 
  if (sp >= tabsize) 
    abortme("Stack overflow"); } /* proc push */ 


integer      pop(void)
{ 
  if (sp > 0) { 
    sp = sp - 1; 
    return stack[sp]; 
  } 
  else 
    return empty; } /* func pop */ 


void         init_tab(void)
{ integer      i; 

  fillchar(string_tab,sizeof(string_tab),0); 
  for (i = 0; i <= 255; i++) 
    upd_tab(no_pred,i); 
  inbuf = empty; 
    /*  outbuf := EMPTY  */ 
} /* proc init_tab */ 


void         init_ucr(integer      i)
{ 
  newhash = i == 1; 
  sp = 0; 
  init_tab(); 
  code_count = tabsize - 256; 
  firstc = true; } /* proc init_ucr */ 


integer      getc_ucr(void)
{ integer      c; 
    integer      code; 
    integer      newcode; 

  if (firstc) { 
    firstc = false; 
    oldcode = gocode(); 
    finchar = string_tab[oldcode].follower; 
    return finchar; 
    return;
    } 
  if (sp == 0) { 
    newcode = gocode(); 
    code = newcode; 
    if (code == -1) { 
      return -1; 
      return;
      } 
    if (!string_tab[code].used) { 
      code = oldcode; 
      push(finchar); 
      } 
    while (string_tab[code].predecessor != no_pred) 
      { void *with1 = &string_tab[code]; 
        push(with1->follower); 
        code = with1->predecessor;    } 
        
    finchar = string_tab[code].follower; 
    push(finchar); 
    if (code_count != 0) { 
      upd_tab(oldcode,finchar); 
      code_count = code_count - 1; 
      } 
    oldcode = newcode; 
    } 
  return pop(); 
} /* func getc_ucr */ 


integer      getcode(void)
{ 
  

  integer      code, r_off, bitsx; 
  byte         bp; 

  if (firstch) 
  { 
    offset = 0; 
    sizex = 0; 
    firstch = false; 
  } 
  bp = 0; 
  if ((clear_flg > 0) || (offset >= sizex) || (free_ent > maxcode)) 
  { 
    if (free_ent > maxcode) 
    { 
      n_bits = n_bits + 1; 
      if (n_bits == bits) 
        maxcode = maxcodemax; 
      else 
        maxcode = (1 << n_bits) - 1; 
    } 
    if (clear_flg > 0) 
    { 
      n_bits = init_bits; 
      maxcode = (1 << n_bits) - 1; 
      clear_flg = 0; 
    } 
    for (sizex = 0; sizex <= n_bits - 1; sizex++) 
    { 
      code = getc_unp(); 
      if (code == -1) 
        goto next;
      else 
        buf[sizex] = code; 
    } 
    sizex = sizex + 1; 

next: if (sizex <= 0) 
    { 
      return -1; 
      return;
    } 
    offset = 0; 
    sizex = (sizex << 3) - (n_bits - 1); 
  } 
  r_off = offset; 
  bitsx = n_bits; 

    /*  get first byte  */ 
  bp = bp + (r_off >> 3); 
  r_off = r_off & 7; 

    /*  get first parft (low order bits)  */ 
  code = buf[bp] >> r_off; 
  bp = bp + 1; 
  bitsx = bitsx - (8 - r_off); 
  r_off = 8 - r_off; 

  if (bitsx >= 8) 
  { 
    code = code | (buf[bp] << r_off); 
    bp = bp + 1; 
    r_off = r_off + 8; 
    bitsx = bitsx - 8; 
  } 

  code = code | ((buf[bp] & rmask[bitsx]) << r_off); 
  offset = offset + n_bits; 
  return code; 
} 


void         decomp(integer      squashflag)
{ 
  

  integer      stackp, finchar; 
  integer      code, oldcode, incode; 


    /*  INIT var  */ 
  if (squashflag == 0) 
     bits = crunch_bits; 
  else 
     bits = squash_bits; 

  if (firstch) 
    maxcodemax = 1 << bits; 

  if (squashflag == 0) { 
     code = getc_unp(); 
     if (code != bits) 
     { 
       printf("File packed with %d bits, I can only handle %d\n",code,bits); 
       exit(0);
     } 
  }   /* if */ 
  clear_flg = 0; 
  n_bits = init_bits; 
  maxcode = (1 << n_bits) - 1; 
  for (code = 255; code >= 0; code--) 
  { 
    prefix[code] = 0; 
    suffix[code] = code; 
  } 

  free_ent = first; 
  oldcode = getcode(); 
  finchar = oldcode; 
  if (oldcode == -1) 
    return;
  if (squashflag == 0) 
     putc_ncr(finchar); 
  else 
     putc_unp(finchar); 
  stackp = 0; 

  code = getcode(); 
  while ((code > -1)) { 
    if (code == clear) 
    { 
      for (code = 255; code >= 0; code--) 
        prefix[code] = 0; 
      clear_flg = 1; 
      free_ent = first - 1; 
      code = getcode(); 
      if (code == -1) 
        goto next;
    } 

next: incode = code; 
    if (code >= free_ent) 
    { 
      stack1[stackp] = finchar; 
      stackp = stackp + 1; 
      code = oldcode; 
    } 
    while ((code >= 256)) { 
      stack1[stackp] = suffix[code]; 
      stackp = stackp + 1; 
      code = prefix[code]; 
    } 
    finchar = suffix[code]; 
    stack1[stackp] = finchar; 
    stackp = stackp + 1; 
    do { 
      stackp = stackp - 1; 
      if (squashflag == 0) 
         putc_ncr(stack1[stackp]); 
      else 
         putc_unp(stack1[stackp]); 
    }  while (!(stackp <= 0)); 
    code = free_ent; 
    if (code < maxcodemax) 
    { 
      prefix[code] = oldcode; 
      suffix[code] = finchar; 
      free_ent = code + 1; 
    } 
    oldcode = incode; 
    code = getcode(); 
  } 
} 


void         unpack(heads *      hdr)
{ integer      c; 

  crcval = 0; 
  size = long_to_real(hdr->size); 
  state = nohist; 
  firstch = true; 
  switch (hdrver) {
    
    case 1:   
    case 2:   { 
           c = getc_unp(); 
           while (c != -1) { 
             putc_unp(c); 
             c = getc_unp(); 
             } 
           } 
    break; 
    
    case 3:   { 
           c = getc_unp(); 
           while (c != -1) { 
             putc_ncr(c); 
             c = getc_unp(); 
             } 
           } 
    break; 
    
    case 4:   { 
           init_usq(); 
           c = getc_usq(); 
           while (c != -1) { 
             putc_ncr(c); 
             c = getc_usq(); 
             } 
           } 
    break; 
    
    case 5:   { 
           init_ucr(0); 
           c = getc_ucr(); 
           while (c != -1) { 
             putc_unp(c); 
             c = getc_ucr(); 
             } 
           } 
    break; 
    
    case 6:   { 
           init_ucr(0); 
           c = getc_ucr(); 
           while (c != -1) { 
             putc_ncr(c); 
             c = getc_ucr(); 
             } 
           } 
    break; 
    
    case 7:   { 
           init_ucr(1); 
           c = getc_ucr(); 
           while (c != -1) { 
             putc_ncr(c); 
             c = getc_ucr(); 
             } 
           } 
    break; 
    
    case 8:   { 
             decomp(0); 
           } 
    break; 
    
    case 9:   { 
             decomp(1); 
           } 
    break; 
    
    default: 
           printf("I dont know how to unpack file %s\n",fn_to_str(&hdr->name)); 
           printf("I think you need a newer version of DEARC\n"); 
           fseek(long_to_real(hdr->size),1); 
           return;
    } /* case */ 
  if (crcval != hdr->crc) 
    printf("WARNING: File %s fails CRC check\n",fn_to_str(&hdr->name)); 
} /* proc unpack */ 


void         extract_file(heads *      hdr)
{ 
  strcpy(extname,fn_to_str(&hdr->name)); 
  printf("Extracting file : %s\n",extname); 
  open_ext(); 
  unpack(hdr); 
  close_ext(); } /* proc extract */ 


void         extarc(void)
{ heads        hdr; 

  open_arc(); 
  while (readhdr(&hdr)) 
    extract_file(&hdr); 
  close_arc(); } /* proc extarc */ 


void         printheading(void)
{ 
  printf("\n"); 
  printf("Turbo Pascal DEARC Utility\n"); 
  printf("Version 3.01, 8/8/87\n"); 
  printf("Supports Phil Katz \"squashed\" files\n"); 
  printf("\n"); 
} /* proc PrintHeading */ 


main(int   argc,
     char  *argv[])
{ 
  printheading();   /*  print a heading  */ 
  getarcname();   /*  get the archive file name  */ 
  extarc();   /*  extract all files from the archive  */ 
}



