Const
	MaxT = 51; {максимальное количество стержней, которое будет рассмотрено}
	MaxD = 50; {максимальное количество дисков}

Var
	t :array[0..50] of longint; {здесь хранятся номера используемых стержней; так как их количество не фиксировано, то для хранения удобней использовать глобальный массив}
	j, k, i, n, m :longint;
	hn :array[4..maxT,0..maxD] of longint; {в этом массиве хранится количество перестановок необходимое для переноса на M стержнях N дисков; веря подсчетам монахов, полагаем что это количество будет небольшим и потребует для хранения всего лишь тип word}
	hr :array[2..maxT,0..maxD] of longint; {в этом массиве хранится разбитие на группы, т.е. сколько дисков из N нужно переносить на M стержнях; остальные нужно переносить на M-1 стержнях}

	h3 :array[0..MaxD] of comp; {так как перестановок может быть очень много, то нам нужен соответствующий тип данных}

procedure Calc3; 
begin
	h3[0]:=0; {0 дисков требуют 0 перестановок}
	for i:=1 to n do
		h3[i]:=2*(h3[i-1]+1)-1; {уже известное рекуррентное соотношение}
end;

Procedure CalcHR3; {записывает разбиение для трех стержней}
Begin
	for i:=1 to n do
		hr[3,i]:=i-1; {на трех стержнях нужно переносит N-1 дмсков}
End; 

Procedure Calc4; {процедура считает наименьшее количество необходимых перестановок для переноса на четырех стержнях дисков в количестве от 1 до N, а также находит разбиения}
Begin
	for i:=1 to n do
	begin
		hr[4,i]:=i-1; {полагает разбиение равным i-1 к 1}
		hn[4,i]:=2*hn[4,i-1]+1; {количество перестановок, которое при этом требуется}
		for j:=i-2 downto 1 do {здесь рассматриваются другие возможные разбиения j к i-j}
			if hn[4,i]>2*hn[4,j]+h3[i-j] then {выбираются разбиения, требующие наименьшего количества перестановок}
			begin
				hr[4,i]:=j;
				hn[4,i]:=round(2*hn[4,j]+h3[i-j]);
			end;
	end;
End;

Procedure CalcM; {считает количество необходимых перестановок и разбиений для от 5 до M стержней и от 1 до N дисков}
Begin {алгоритм тот же, что и в Calc4, только более общий}
	Calc4;
	for i:=5 to m do 
		for j:=1 to n do
		begin
			hr[i,j]:=j-1; 
			hn[i,j]:=2*hn[i,j-1]+1;
			for k:=j-2 downto 1 do
				if hn[i,j]>2*hn[i,k]+hn[i-1,j-k] then
				begin
					hr[i,j]:=k;
					hn[i,j]:=2*hn[i,k]+hn[i-1,j-k];
				end;
		end;
End;

Procedure Swap(i,j : longint); {процедура, меняющая местами элементы массива T}
var
	temp :longint;
Begin
	temp:=t[i]; {пример обмена значений двух числовых переменных}
	t[i]:=t[j];
	t[j]:=temp;
End;

Procedure Hanoi(n,m : longint); {модифицированная процедура из программы Hanoi3, n — количество дисков, которые надо перенести с первого на последний стержень, m — количество стержней}
Begin
	if n=1 then
		writeLn(t[1],' --> ',t[m],'; ') { тривиальный перенос одного диска}
	else
	begin
		Swap(m,m-1); {поменять стержни m и m-1 местами}
		Hanoi(hr[m,n],m); {перенести какое-то количество с помощью m стержней на m-1'ый стержень}
		Hanoi(n-hr[m,n],m-1); {перенести остальные диски с помощью m-1 стержня на m'ый стержень}
		Swap(m,m-1); {обратно поменять m и m-1 стержни местами}
		Swap(1,m-1); {сделать m-1'ый стержень стартовым}
		Hanoi(hr[m,n],m); {перенести оставшиеся диски с m-1'ого на m'ый стержень, используя m стержней}
		Swap(1,m-1); {восстановить порядок стержней}
	end;
End;

Begin
	{ввод m>=3 и n<=50}
	m := 2;
	n := 51;

	while (m<3) and (n>50) do
	begin
		WriteLn('введите числоm башен (m) >= 3 и число дисков (n) <=50');
		ReadLn(m,n);
	end;

	fillchar(hn,sizeof(hn),0);
	fillchar(hr,sizeof(hr),0);

	Calc3;
	CalcHR3;

	if m>3 then
		CalcM;

	for i:=0 to m do
		t[i]:=i; {начальный порядок стержней}

	Hanoi(n,m);
End.
