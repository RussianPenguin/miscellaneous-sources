;prg_11_4.asm
MASM
MODEL	small
STACK	256
.data
;матрица размером 2x5 - если ее не инициализировать, то для наглядности она может быть описана так:
;array dw 2 DUP (5 DUP (?))
;но мы ее инициализируем:
array	dw	1,2,3,4,5,6,7,3,9,0
;логически это будет выглядеть так:
;array=	{1	2}
;		{3	4}
;		{5	6}
;		{7	3}
;		{9	0}
	elem	dw	3	;элемент для поиска
failed	db	0ah,0dh,'Нет такого элемента в массиве!','$'
success db 0ah,0dh,'Такой элемент в массиве присутствует ','$'
foundtime	db ?	;количество найденных элементов
fnd	db	' раз(а)',0ah,0dh,'$'
.code
main:
	mov	ax,@data
	mov	ds,ax
	xor	ax,ax
	mov	si,0	;si=столбцы в матрице
	mov	bx,0	;bx=строки в матрице
	mov	cx,5	;число для внешнего цикла (по строкам)
external:		;внешний цикл по строкам
	mov	ax,array[bx][si]	;в ax первый элемент матрицы
	push	cx	;сохранение в стеке счётчика внешнего цикла
	mov	cx,2	;число для внутреннего цикла (по столбцам)
	mov	si,0
iternal:		;внутренний цикл по строкам
	inc	si	;передвижение на следующий элемент в строке
;сравниваем содержимое текущего элемента в ax с искомым элементом:
	cmp	ax,elem
;если текущий совпал с искомым, то переход на here для обработки,
;иначе цикл продолжения поиска
	je	here
;иначе - цикл по строке cx=2 раз
	loop	iternal
here:
	jcxz	move_next	;просмотрели строку?
	inc	foundtime	;иначе увеличиваем счётчик совпавших
move_next:	;продвижение в матрице
	pop	cx	;восстанавливаем CX из стека (5)
	add	bx,1	;передвигаемся на следующую строку
	loop	external	;цикл (внешний)
	cmp	foundtime,0h	;сравнение числа совпавших с 0
	ja	eql	;если больше 0, то переход
not_equal:		;нет элементов, совпавших с искомым
	mov	ah,09h	;вывод сообщения на экран
	mov	dx,offset failed
	int	21h
	jmp	exit	;на выход
eql:		;есть элементы, совпавшие с искомым
	mov	ah,09h	;вывод сообщений на экран
	mov	dx,offset success
	int	21h
	mov	ah,02h
	mov	dl,foundtime
	add	dl,30h
	int	21h
	mov	ah,09h
	mov	dx,offset fnd
	int	21h
exit:			;выход
	mov	ax,4c00h	;стандартное завершение программы
	int	21h
end	main	;конец программы

